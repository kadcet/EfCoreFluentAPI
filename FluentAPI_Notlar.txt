Domain katmanýnda varlýklarýmýzý tanýmlýyoruz.

PersistLayer de bunun kalýcýlýkla ilgili olan yani veritabaný operasyonlarýnýn bulunduðu kodlarý yazýyoruz.

WinFormUI görsel katmandaki operasyonlarý yönetiyor.

Product a Category türünden propery tanýmladýk.
public Category Category { get; set; }
bunu neden koyduk.
Bir Product ý talep ettiðim zaman kategoriside gelsin diye. Navigation Property
Product ý çektiðimde Category adýna yada o kategori ile ilgili kaç tane property varsa ulaþabileyim.

Category ve Product Id leri Baseentity den geliyor. Property olarak yok.
Product ta CategoryId property si tanýmladým ama Category de Property olarak yok. BaseEntity den geliyor.
Burda Conventions çalýþmaz. Bunu özellikle birdirmemiz gerekiyor. Bunu FlentAPI ile yapýyruz. 
Category e ICollection ile Product tanýmlar, Product a CayegoryId tanýmlarsak FluentAPI bunlarý ForeignKey yapýyor.
Domain katmaný baþka katmanlar için kod içermez.
Mimari yaklaþýmlarda Damin de attribute ile yapýlmaz. Bu yapýlanlarmalar PersistLayerde FluentAPI ile yapýlacak.

Category ve Product nesneleri ve property lerini ekledik ve migration yaptýk.
Hata aldýk.
Microsoft.EntityFrameworkCore.Design paketini WinFormUI a kurmamýz lazým
Tekrar migration ekledik
Hata aldýk.
EFCorePersistLayer ýn winformUý a referans edildiðinden emin ol diyor.
WinFormUI=> Dependencis=> add project references + EFCorePersistLayer

Update-Database yaptýk. Categories tablosundaki Id kolonu  ile Products kolonundaki CategoryId Foreignkey olarak ayarlamýþ
ýnsert update specification da delete=cascade, update=no action tanýmlý
int notnull deðil nullable,nvarcharmax yapmak vb gibi iþlemleri 
2 yöntemle yapabiliriz.

1- DataAnnotations => .Net Frameworkte var olan attribute frameworkü
2- FluentAPI    => ModelBuilder ile


** IncludeTax ý veritabanýnda saklama demiþ olduk.
modelBuilder.Entity<Product>().Ignore(c => c.IncludeTax);    


** Price alanýný decimal(9,2) ve IsRequired(); ile zorunlu alan yaptýk. IsRequired(); true geliyor. Zorunlu olmasýn dersek False yapabiliriz.IsRequired(false);
modelBuilder.Entity<Product>().Property(p => p.Price).HasColumnType("decimal(9,2)").IsRequired();

** Product ýn Name sinin uzunluðunu max uzunluðunu 128 yaptýk ve zorunlu olmasýný tanýmladýk.
modelBuilder.Entity<Product>().Property(p => p.Name).HasMaxLength(128).IsRequired();


** Bire Çok Ýliþki **
modelBuilder.Entity<Product>()
				.HasOne<Category>(p => p.Category)   / Product ýn sahip olduðu bir Category si var
				.WithMany(c => c.Products)           / Ve bu iliþki çok olan taraf Product tarafýdýr. Birçok Product a sahiptir.
				.HasForeignKey(p => p.CategoryId)    / Bu iliþki þu  ForeignKey üzerine kurulur.
				.OnDelete(DeleteBehavior.SetNull);   / Category silinirse Product taki CategoryId null olsun dedik. Bunun için ProductId zorunluluðunu kaldýrmamýz lazým

Migration ekledik
Hata aldýk
The property 'Product.CategoryId' cannot be marked as nullable/optional because the type of the property is 'int' which is not a nullable type.
Any property can be marked as non-nullable/required, but only properties of nullable types can be marked as nullable/optional.

int nullable bir tip deðil.Veri tabanýndaki null alaný Product entity sine çekmeye kaltýðýmda burdaki alan nullable olmadýðý için çekemiycek
Bunun için Product taki CategoryId property sini böyle tanýmladýk. Null olabilir demiþ olduk
public int? CategoryId { get; set; }

** Bire Bir Ýliþki **
modelBuilder.Entity<Customer>()
					.HasOne<CustomerAddress>(c=>c.Address)
					.WithOne(ca => ca.Customer)
					.HasForeignKey<CustomerAddress>(ad => ad.AddressOfCustomerId)
					.OnDelete(DeleteBehavior.Cascade);




